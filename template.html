<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="logoslide nobackground dark">
    <article class="flexbox vcenter">
      <span><img src="images/breizhcamp-splash.png"></span>
    </article>
  </slide>

  <slide class="title-slide segue nobackground">
    <aside class="note">
      <section>
        <ul>
          <li>prez assez dense, bcp de choses, slides sur github</li>
          <li>pas un inventaire, ni des commandes, ni des raccourcis</li>
          <li>quelques trucs et astuces + idée générale des possibilités de bash</li>
          <li>j'ai appris des trucs en préparant</li>
        </ul>
      </section>
    </aside>
    <aside class="gdbar"><img src="images/breizhcamp-logo.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
    <img style="position: absolute; left: 850px; top: 535px;" src="images/obs.jpg">
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>charité bien ordonnée commence par soi-même ! bash après...</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>moi</h2>
    </hgroup>
    <article class="flexbox vcenter">
      <p>Orange / IT&amp;Labs</p>
      <p>développeur Java / architecte logiciel</p>
      <p>admin système Linux</p>
      <p>15 ans Linux</p>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>automatiser, traitements jetables de données textuelles (log par exemple)</li>
          <li>le fait de l'utiliser tout le temps permet de se créer des réflexes</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>pourquoi utiliser un shell sur son poste ?</h2>
      <h3>alors qu'on a une souris !</h3>
    </hgroup>
    <article>
      <ul>
        <li>plus efficace que le clic !</li>
        <li>seule solution pour interagir avec un serveur Linux distant (dans le cloud)</li>
        <li>un peu dur de plonger dedans...
          <ul>
            <li>une distrib linux contient plusieurs milliers de programmes !</li>
          <pre class="prettyprint"  data-lang="shell">
bash$ ls -1 /bin /usr/bin | wc -l
3280
</pre>
            <li>syntaxe hétérogène entre les programmes</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>scripts d'install, de boot</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>BASH</h2>
      <h3>the Bourne-Again Shell</h3>
    </hgroup>
    <article>
      <ul>
        <li>le shell du projet GNU => utilisé par defaut dans les distribs Linux</li>
        <li>un shell parmis d'autres (sh, zsh, ksh, ...)</li>
        <li>un programme <b>comme</b> les autres (pas de privilèges particuliers)</li>
        <li>exécute des commandes
          <ul>
            <li>tapées au clavier depuis un terminal</li>
            <li>issues d'un script</li>
          </ul>
        </li>
        <li>très configurable (<code>~/.bashrc</code>, <code>~/.inputrc</code>, ...)</li>
      </ul>
    </article>
  </slide>

  <slide class="segue quote dark">
    <article class="flexbox vcenter">
      <h2>fonctionnalités interactives</h2>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>pas d'inventaire, juste ce qui sert tout le temps</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>éditeur de la ligne courante</h2>
    </hgroup>
    <article>
      <ul>
        <li>éditeur de texte mono-ligne</li>
        <li>préfixé par un prompt pour avoir des informations contextuelles</li>
        <li>raccourcis de navigation en mode par défaut (emacs)
          <ul>
            <li><code>CTRL-GAUCHE</code> / <code>CTRL-DROITE</code> : mot précédent / mot suivant</li>
            <li><code>CTRL-A</code> / <code>CTRL-E</code> : va au début / à la fin de la ligne</li>
            <li><code>CTRL-W</code> : supprime le mot précédent</li>
            <li><code>CTRL-U</code> / <code>CTRL-K</code> : supprime la ligne jusqu'au début / jusqu'à la fin</li>
          </ul>
        </li>
        <li>contrôle d'exécution
          <ul>
          <li><code>CTRL-C</code> : arrête la commande en cours</li>
          <li><code>CTRL-Z</code> : gèle la commande en cours</li>
          <li><code>CTRL-D</code> : quitte le shell</li>
        </ul>
        <li>astuce : mettre en commentaires la ligne en cours permet de se la garder sous le coude pour plus tard (séquence <code>CTRL-A</code>, <code>#</code>, <code>ENTRÉE</code>)</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>la complétion</h2>
    </hgroup>
    <article>
      <ul>
        <li>touche <code>TAB</code> complète la ligne en cours avec soit :
          <ul>
            <li>nom de commande</li>
            <li>nom de fichier ou répertoire</li>
            <li>nom de variable</li>
          </ul>
        </li>
        <li>completion contextuelle à la commande avec <code>bash_completion</code>
          <ul>
          <pre class="prettyprint" data-lang="shell">
$ git &lt;TAB&gt;
add                   commit                instaweb              rm 
am                    config                l                     s 
...
</pre>
            <li>implémenté par des fonctions BASH (<code>/etc/bash_completion.d/</code>)</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>la complétion</h2>
      <h3>configuration améliorée</h3>
    </hgroup>
    <article>
      <p>dans le fichier <code>~/.inputrc</code></p>
          <pre class="prettyprint">
$include /etc/inputrc

# ignore la case
set completion-ignore-case on

# treats hyphens ('-') and underscores ('_') as equivalent
set completion-map-case on

# ignorer les fichiers cachés
set match-hidden-files off

# affiche directement les completions possibles (évite de taper <code>TAB</code> 2 fois)
set show-all-if-ambiguous on
</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>historique des commande</h2>
    </hgroup>
    <article>
      <ul>
        <li>garde en 'mémoire' les commandes précédemment exécutées
          <ul>
            <li>stocké dans <code>~/.bash_history</code></li>
            <li>500 lignes conservées par défaut</li>
          </ul>
        </li>
        <li>touche <code>HAUT</code> / <code>BAS</code> : commande précédente / suivante
          <ul>
            <li>peu efficace avec un gros historique</li>
          </ul>
        </li>
        <li><code>CTRL-R</code> : recherche mot-clé dans l'historique</li>
        <li><code>ALT-.</code> : répère le dernier argument de la commande précédente</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>historique des commande</h2>
      <h3>configuration améliorée</h3>
    </hgroup>
    <article>
      <ul>
        <li>recherche incrémentale avec <code>HAUT</code> / <code>BAS</code> (dans <code>~/.inputrc</code>)</li>
          <pre class="prettyprint">
"\e[A": history-search-backward
"\e[B": history-search-forward
</pre>
        <li>un gros historique (dans <code>~/.bashrc</code>)</li>
          <pre class="prettyprint" data-lang="bash">
HISTSIZE=20000
HISTFILESIZE=20000
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>le prompt</h2>
    </hgroup>
    <article>
      <ul>
        <li>ce qu'affiche le shell avant la zone d'édition</li>
          <pre class="prettyprint" data-lang="shell">
yoann@computer:~/breizhcamp-bashetmoi $
</pre>
        <li>assez basique par défaut mais fortement personnalisable</li>
        <li>variable <code>PS1</code>, évaluée à chaque affichage
          <ul>
            <li>peut inclure des informations contextuelles</li>
            <li>peut inclure des appels de fonctions</li>
          </ul>
        </li>
        <li>configuration à mettre dans <code>~/.bashrc</code></li>
      </ul>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>contexte git : branche, état par rapport au distant</li>
          <li>code retour et temps d'exécution de la dernière commande</li>
          <li>processus attachés</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>un prompt clé en main : <code>liquidprompt</code></h2>
    </hgroup>
    <article>
      <ul>
        <li>affiche élégamment des informations utiles uniquement quand le contexte le demande</li>
        <li>https://github.com/nojhan/liquidprompt</li>
      </ul>
      <img src="images/liquidprompt.png" alt="mon terminal" title="mon terminal">
    </article>
  </slide>

  <slide class="segue quote dark">
    <article class="flexbox vcenter">
      <h2>ok, mais qu'est qu'on tape ?</h2>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>pas un cours magistral sur le langage bash</li>
          <li>interactif : attend une ligne de commande</li>
          <li>une ligne de commande contient
            <ul>
              <li>nom d'une commande à exécuter</li>
              <li>liste d'arguments à passer</li>
            </ul>
          </li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>la ligne de commande</h2>
      <h3>petits rappels...</h3>
    </hgroup>
    <article>
      <ul>
        <li>on tape des commandes !</li>
        <li>navigation et manipulation de répertoires (<code>cd</code>, <code>mkdir</code>, <code>rmdir</code>, ...)</li>
        <pre class="prettyprint" data-lang="shell">
[yoann:~]$ mkdir test
[yoann:~]$ cd test
[yoann:~/test]$ ls
[yoann:~/test]$
</pre>
        <li>gestion de fichiers (<code>ls</code>, <code>cp</code>, <code>mv</code>, <code>rm</code>, ..)</li>
        <pre class="prettyprint" data-lang="shell">
[yoann:~]$ ls
template.html
[yoann:~]$ cp template.html template.html.old
[yoann:~]$ ls
template.html  template.html.old
[yoann:~]$ rm template.html
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>la ligne de commande</h2>
      <h3>petits rappels...</h3>
    </hgroup>
    <article>
      <ul>
        <li>l'évaluation est plus complexe qu'un simple lancement de programme
        <li>applique des substitutions (variables, caractères spéciaux, ...)</li>
        <pre class="prettyprint" data-lang="shell">
[yoann:~]$ echo ${PWD}
/home/yoann
[yoann:~]$ echo *
template.html.old
</pre>
        <li>interprète les constructions du langage et exécute les programmes</li>
        <pre class="prettyprint" data-lang="shell">
[yoann:~]$ for i in {1..5}; do echo -n "$i "; done
1 2 3 4 5
</pre>
        <li>c'est un vrai langage de programmation !</li>
      </ul>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>philosophie des outils Unix : un programme => un besoin</li>
          <li>un shell pour les lier entre eux</li>
          <li>liste des commandes ici couvre 80% des besoins</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>commandes de base pour survivre</h2>
    </hgroup>
    <article>
      <ul>
        <li>exécutables systèmes : 
          <ul>
            <li>cp, mv, rm, mkdir, rmdir, chown, chmod</li>
            <li>ls, find, stat</li>
            <li>grep, wc, tr, sort, uniq, head, cut, cat, echo, tail(f), more, less, join, date</li>
            <li>xargs, sed, awk</li>
          </ul>
        </li>
        <li>internes bash :
          <ul>
            <li>cd, pwd</li>
            <li>export, set, env</li>
            <li>if, then, else, fi, for, while, do, done</li>
            <li>|, ||, &amp;, &amp;&amp;</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>à l'aide !!!</h2>
    </hgroup>
    <article>
      <ul>
        <li>utiliser le <code>man</code></li>
        <pre class="prettyprint" data-lang="shell">
bash$ man ls
</pre>
        <li>lancer une commande avec <code>-h</code> ou <code>--help</code></li>
        <pre class="prettyprint" data-lang="shell">
bash$ ls --help
Utilisation : ls [OPTION]... [FILE]...
Afficher des renseignements sur les FILEs (du répertoire actuel par défaut).
Trier les entrées alphabétiquement si aucune des options -cftuvSUX ou --sort
ne sont utilisées.

Les arguments obligatoires pour les options longues le sont aussi pour les
options courtes.
  -a, --all                  ne pas ignorer les entrées débutant par .
  -A, --almost-all           ne pas inclure . ou .. dans la liste
</pre>
      </ul>
    </article>
  </slide>

  <slide class="segue quote dark">
    <aside class="note">
      <section style="color:black">
        <ul>
          <li>pas assez de temps pour un cours magistral sur bash</li>
          <li>décortique 3 exemples d'utilisation typique du langage</li>
        </ul>
      </section>
    </aside>
    <article class="flexbox vcenter">
      <h2>exemples de <span style="text-decoration:line-through;">programmes<span></h2>
      <h2 style="margin-top:20px;">lignes de commande...</h2>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>les 2 commandes que j'utilise le plus</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
   3682 cd
   2967 ls
</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>pipeline de commandes</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
          ^                  ^      ^         ^              ^
</pre>
      <ul>
        <li>opérateur pipe : <code><span style="font-style: italic;">command A</span> | <span style="font-style: italic;">command B</span></code>
          <ul>
            <li>connecte la sortie standard de <code>A</code> vers l'entrée de <code>B</code></li>
            <li>les 2 processus s'exécutent en même temps</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>les commandes utilisées</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
</pre>
      <ul>
        <li><code>history</code> : affiche l'historique</li>
      <pre class="prettyprint" data-lang="shell">
$ history
  497  ls
  498  vi .inputrc 
  499  cat /etc/inputrc 
  500  ls
  501  history
</pre>
        <li><code>awk</code> : traitement de chaines (recherches, remplacements, transformations)</li>
      <pre class="prettyprint" data-lang="shell">
$ history | awk '{print $2}'
ls
vi
cat
...
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>les commandes utilisées</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
</pre>
      <ul>
        <li><code>sort</code> : tri le texte entrée</li>
      <pre class="prettyprint" data-lang="shell">
$ history | awk '{print $2}' | sort
cat
history
ls
ls
vi
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>les commandes utilisées</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
</pre>
      <ul>
        <li><code>uniq</code> : supprime les doublons consécutifs
          <ul>
            <li><code>-c</code> : préfixe avec le compte</li>
          </ul>
        </li>
      <pre class="prettyprint" data-lang="shell">
$ history | awk '{print $2}' | sort | uniq -c
 1 cat
 1 history
 2 ls
 1 vi
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>les commandes utilisées</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr | head -2
 2 ls
 1 cat
</pre>
      <ul>
        <li><code>sort</code> : tri le texte entrée
          <ul>
            <li><code>-k1,1</code> : clé de tri => 1ère colonne</li>
            <li><code>-n</code> : tri numérique</li>
            <li><code>-r</code> : inverse le tri</li>
          </ul>
        </li>
        <li><code>head</code> : affiche le début</li>
      </ul>
    </article>
  </slide>

  <slide>
    <aside class="note">
      <section style="color:black">
        <ul>
          <li>stocké le résultat dans un fichier horodaté</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>exemple 1 : mise en bouche</h2>
      <h3>redirection dans un fichier</h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ history | awk '{print $2}' | sort | uniq -c | sort -k1,1nr > hist-$(date +%Y%m).txt
$ head hist-201405.txt
   3682 cd
   2967 ls
   2364 git
   ...
</pre>
      <ul>
        <li>opérateur <code>&gt;</code> : redirige la sortie standard dans un fichier</li>
        <li>opérateur <code>$(<span style="font-style: italic;">command</span>)</code> : substitue l'argument par la sortie standard de l'exécution de <code>command</code></li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ find * -name ".git" | while read d ; do d=${d%.git} ; ( cd "$d" && git branch
  --list | grep -q mybranch && echo "$d" ) ; done
</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ find * -name ".git" | while read d ; do d=${d%.git} ; ( cd "$d" && git branch
  --list | grep -q mybranch && echo "$d" ) ; done
dépot-3/
dépot-5/
dépot-8/
</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
$ find * -name ".git" | while read d ; do d=${d%.git} ; ( cd "$d" && git branch
  --list | grep -q mybranch && echo "$d" ) ; done
dépot-3/
dépot-5/
dépot-8/
</pre>
      <p>reformattons !</p>
      <pre class="prettyprint">
$ find * -name ".git" | \
  while read d ; do \
    d=${d%.git} ; \
    ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
  done
</pre>
    <p>le caractère <code>\</code> permet d'échapper le retour chariot</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
-> $ find * -name ".git" | \
     while read d ; do \
       d=${d%.git} ; \
       ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
     done
</pre>
      <ul>
        <li>métacaractère <code>*</code> remplacé par la liste des fichiers dans le répertoire courant</li>
        <li>commande <code>find</code> : recherche récursive de fichiers par critères</li>
        <pre class="prettyprint">
$ find * -name ".git"
dépot-1/.git
dépot-2/.git
dir-1/dépot-Z/.git
...
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
   $ find * -name ".git" | \
->   while read d ; do \
       ...
->   done
</pre>
      <ul>
        <li>commande <code>while x; do <span style="font-style: italic;">command</span> ; done </code>
          <ul>
            <li>boucle exécutant <code>command</code> tant que la commande <code>x</code> réussi</li>
          </ul>
        </li>
        <li><code>;</code> sépare une liste de commandes exécutées séquentiellement</li>
        <li>commande <code>read <span style="font-style: italic;">var</span></code>
          <ul>
            <li>assigne à <code><span style="font-style: italic;">var</span></code>
            une ligne lue depuis l'entrée standard</li>
            <li>succès tant que l'entrée standard n'est pas vide (code retour 0)</li>
          </ul>
        </li>
      </ul>
      <p>note : construction fonctionnant avec des noms de fichiers ayant des espaces</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
   $ find * -name ".git" | \
     while read d ; do \
->     d=${d%.git} ; \
       ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
     done
</pre>
      <ul>
        <li>assignation <code>varname = value</code></li>
        <li>Shell Parameter Expansion
          <ul>
            <li><code>${variable%word}</code> enlève <code>word</code> à la fin de <code>variable</code></li>
            <li><code>${variable#word}</code> enlève <code>word</code> du début de <code>variable</code></li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
   $ find * -name ".git" | \
     while read d ; do \
       d=${d%.git} ; \
->     ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
     done
</pre>
      <p>sous shell : <code>( <span style="font-style: italic;">command</span> )</code></p>
      <ul>
        <li>exécute <code><span style="font-style: italic;">command</span></code> dans un nouveau process bash</li>
        <li>permet de ne pas polluer le process principal</li>
      </ul>
      <pre class="prettyprint">
$ ps | grep bash | wc -l
1
$ ( ps | grep bash | wc -l )
2
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
   $ find * -name ".git" | \
     while read d ; do \
       d=${d%.git} ; \
->     ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
     done
</pre>
      <p>liste de commandes</p>
      <ul>
        <li><code>command A && command B</code> : exécute <code>B</code> si <code>A</code> a réussie (ET logique)</li>
        <li><code>command A || command B</code> : exécute <code>B</code> si <code>A</code> a échouée (OU logique)</li>
        <li><code>command A ; command B</code> : exécute <code>A</code> puis <code>B</code></li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 2 : on en veut plus</h2>
      <h3>liste des dépôts <code>git</code> ayant une branche nommée <span style="font-style: italic;">mybranch</span></h3>
    </hgroup>
    <article>
      <pre class="prettyprint">
   $ find * -name ".git" | \
     while read d ; do \
->     d=${d%.git} ; \
       ( cd "$d" && git branch --list | grep -q mybranch && echo "$d" ) ; \
     done
</pre>
      <ul>
        <li>command <code>grep</code> : recherche de pattern dans un fichier ou l'entrée standard
          <ul>
            <li><code>-q</code> : mode silencieux (quiet)</li>
            <li>code retour 0 si pattern trouvé</li>
          </ul>
        </li>
        <li>command <code>echo</code> : affiche les arguments passés</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>exemple 3 : super combo !</h2>
    </hgroup>
    <article>
      <ul>
        <li>génère un changelog unifié à partir de changelog Debian d'un ensemble de sous-modules</li>
      </ul>
      <pre class="prettyprint" data-lang="bash">
$ git diff --submodule=log $COMMIT_START $COMMIT_END | \
  sed -n -r 's|^Submodule ([^ ]+) ([0-9a-f]{7}\.?\.\.[0-9a-f]{7})[: ].*|\1 \2|p' | \
  while read sm vv ; do \
    v1=${vv%%..*} ; v2=${vv##*..} ; \
    echo ">>> ${sm} (${v1}..${v2})" >&2 ; \
    if [[ ${v1} = 0000000 ]] ; then \
      cat "${sm}/debian/changelog" ; \
    else \
      git --git-dir="${sm}/.git" diff "${v1}..${v2}" -- debian/changelog | \
        sed -n '/^+++/!s:^+::p' ;\
    fi ;\
  done
</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>du one-liner au script</h2>
    </hgroup>
    <article>
      <ul>
        <li>fichier texte avec droits d'exécution : <code>chmod +x myscript.sh</code></li>
        <li>entête spécial avec le shebang : <code>#!/bin/bash</code></li>
        <li>possibilité de définir des fonctions pour organiser son code</li>
        <pre class="prettyprint" data-lang="bash">
#!/bin/bash
function usage { 
  echo 'Salut le BreizhCamp'; exit 1
}
[[ $# == 0 ]] && usage
echo "$@"
</pre>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>quelques tips</h2>
    </hgroup>
    <article>
      <ul>
        <li>expansion de crochet : <code>{mot1,mot2}</code></li>
          <pre class="prettyprint" data-lang="bash">
$ echo mv realllylongname.cpp{,-old}
mv realllylongname.cpp realllylongname.cpp-old
</pre>
        <li>revenir au répertoire précédant</li>
          <pre class="prettyprint" data-lang="bash">
$ cd -
</pre>
        <li>renommage massif de fichiers</li>
          <pre class="prettyprint" data-lang="bash">
$ rename 's/old/new/' *.java
</pre>
        <li>opérateur <code>&lt;(command)</code> : expose le flux de sortie de <code>command</code> comme un fichier</li>
          <pre class="prettyprint" data-lang="shell">
$ diff &lt;(sort -u file1) &lt;(sort -u file2)
</pre>
        <ul>
          <li>évite de créer des fichiers temporaires dans des cas complexes</li>
        </ul>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>quelques tips</h2>
    </hgroup>
    <article>
      <ul>
        <li><code>sed</code> (stream editor) : outil de manipulation de texte permettant d'inserer, de supprimer, de chercher et replacer du texte
          <ul>
            <li>substitution simple dans un fichier</li>
            <pre class="prettyprint" data-lang="bash">
$ sed -e 's/foo/bar/' myfile.txt
</pre>
            <li>liste des suffixes de recherche DNS</li>
            <pre class="prettyprint" data-lang="bash">
$ sed -n 's/^search //p' /etc/resolv.conf
</pre>
          </ul>
        </li>
        <li><code>jq</code> (JSON processor) : équivalent de sed pour des données JSON</li>
        <li><code>sponge</code> : l'éponge à fichier (paquet <code>moreutils</code>)
          <ul>
            <li></li>
            <pre class="prettyprint" data-lang="shell">
bash$ sort test.csv | sponge test.csv
</pre>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>les alias</h2>
    </hgroup>
    <article>
      <p>raccourcis vers une commande ou pré-configuration</p>
      <pre class="prettyprint" data-lang="bash">
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
# accès rapide au répertoire du projet foo
alias cdf='cd ~/Projets/foo'
</pre>
      <p>généralement définis dans <code>~/.bash_aliases</code></p>
    </article>
  </slide>

  <slide class="segue dark quote">
    <article class="flexbox vleft">
      <h2>Autour de BASH</h2>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2><code>tmux</code> : un multiplexeur de terminal</h2>
    </hgroup>
    <article class="flexbox vcenter">
      <img src="images/tmux-htop.png">
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2><code>tmux</code> : un multiplexeur de terminal</h2>
    </hgroup>
    <article>
      <ul>
        <li>plusieurs terminaux virtuels dans une même fenêtre (multiplexe le terminal)</li>
        <li>détachement / rattachement d'une session</li>
        <li>visualisation de plusieurs processus en même temps</li>
        <li>multiplexage du clavier possible<ul><li>permet d'exécuter une commande sur plusieurs serveurs en même temps</li></ul></li>
        <li>alternative à GNU <code>screen</code></li>
      </ul>
    </article>
  </slide>  

  <slide>
    <aside class="note">
      <section>
        <ul>
          <li>si vous regardez le monde Unix par la fenêtre...</li>
          <li>outilllage console est plutôt limité...
            <ul>
              <li>peut-on appeler <code>cmd.exe</code> un shell ?</li>
              <li>le 'terminal' n'est pas très agréable : 80 colonnes non redimensionnable (enfin si, dans menu1 / menu2 / menu3, 4ème onglet), copier / coller pénible</li>
            </ul>
          </li>
          <li>PowerShell</li>
        </ul>
      </section>
    </aside>
    <hgroup>
      <h2>vu de la fenêtre</h2>
    </hgroup>
    <article>
      <ul>
        <li><code>Chocolatey</code>
          <ul>
            <li>outil d'installation automatique de paquets logiciels pour Windows</li>
            <li>équivalent de <code>apt-get</code> ou <code>yum</code></li>
            <li><a href="https://chocolatey.org">https://chocolatey.org</a></li>
          </ul>
        </li>
        <li><code>ConsoleZ</code> : une <b>vrai</b> console (copier / coller, redimensionnement, ...)</li>
          <pre class="prettyprint">
c:\> cinst ConsoleZ
</pre>
        <li>BASH existe sous Windows !
          <ul>
            <li><code>MinGW</code> : Minimalistic GNU for Windows</li>
          <pre class="prettyprint">
c:\> cinst mingw
</pre>
            <li><code>Cygwin</code> : couche de compatibilité Linux pour Windows</li>
          <pre class="prettyprint">
c:\> cinst Cygwin
</pre>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>liens</h2>
    </hgroup>
    <article>
      <ul>
        <li><a href="http://www.gnu.org/software/bash/manual/">Bourne-Again SHell manual (GNU)</a></li>
        <li><a href="http://www.tldp.org/LDP/abs/html/">Advanced Bash-Scripting Guide (TLDP)</a></li>
        <li><a href="http://superuser.com">http://superuser.com</a> : stackoverflow de la ligne de commande</li>
        <li><a href="http://explainshell.com">http://explainshell.com</a></li>
        <li><a href="https://dotfiles.github.io">projet dotfiles de github</a></li>
        <li><a href="https://github.com/search?q=dotfiles&ref=cmdform">repos de dotfiles sur github</a></li>
      </ul>
    </article>
  </slide>

  <slide class="thank-you-slide dark segue nobackground">
    <aside class="note">
      <section>
        <ul>
          <li>j'espère vous avoir donner envie de creuser</li>
          <li>éviter les très gros scripts => préférer python, ruby, groovy</li>
        </ul>
      </section>
    </aside>
    <aside class="gdbar right"><img src="images/breizhcamp-logo.png"></aside>
    <article class="flexbox vleft">
      <h2>questions ?</h3>
    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
    <img style="position: absolute; left: 850px; top: 535px;" src="images/obs.jpg">
  </slide>

  <slide class="thank-you-slide dark segue nobackground">
    <aside class="gdbar right"><img src="images/breizhcamp-logo.png"></aside>
    <article class="flexbox vleft">
      <h2>Votez +1 ou bashez moi :) </h3>
    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
    <img style="position: absolute; left: 850px; top: 535px;" src="images/obs.jpg">
  </slide>

  <slide class="backdrop"></slide>
</slides>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
